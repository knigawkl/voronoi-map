\documentclass[a4paper,11pt]{article}
\newcommand\tab[1][0.6cm]{\hspace*{#1}}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{lastpage}

\rfoot{\thepage \hspace{lpt} / \pageref{LastPage}}

\title{ \sc{Specyfikacja implementacyjna} \\
\emph{Projekt zespołowy} }

\author{Mateusz Smoliński \and Łukasz Knigawka}

\begin{document}

\maketitle

\thispagestyle{empty}

\tableofcontents

\newpage

\section{Wstęp}

\tab Celem projektu jest napisanie programu prezentującego interaktywną mapę na podstawie danych z pliku wejściowego. Program otrzymuje punkty tworzące kontur mapy, punkty kluczowe, na podstawie których kontur zostaje podzielony na obszary, a także definicje obiektów oraz listę takowych obiektów, które mają być brane pod uwagę przy analizie wyżej wspomnianych obszarów.

Jeśli dane będą podane prawidłowo, program na ich podstawie generuje planszę, która dalej może być modyfikowana przez użytkownika. Może on dodawać i usuwać elementy konturu, zmieniając kształt mapy, a także dodawać i usuwać punkty kluczowe, wpływając tym samym na podział na obszary. Po kliknięciu na jeden z punktów kluczowych użytkownik otrzyma informacje o obiektach znajdujących się na wyznaczonym przez niego obszarze.

Projekt ,,LUPA'' zostanie napisany w języku C\# wersji 7.3 (.NET Framework 4.7.2), w środowisku Microsoft Visual Studio 15.9.4. Interfejs użytkownika zostanie utworzony dzięki platformie WPF. Implementacja oraz testowanie programu odbywać się będą na komputerach o następujących parametrach: 
\begin{itemize}

\item 64-bitowy system operacyjny Windows 10 Home ver. 1803,
\item procesor Intel Core i5-7200U,
\item pamięć RAM 8,00 GB,
\item karty graficzne Intel HD Graphics 620 + NVIDIA GeForce 940MX,

\end{itemize}

oraz:

\begin{itemize}

\item 64-bitowy system operacyjny Windows 10 Home ver. 1803,
\item procesor Intel Core i7-6700HQ,
\item pamięć RAM 16,00 GB,
\item karty graficzne Intel HD Graphics 530 + NVIDIA GeForce 940MX,

\end{itemize}

\section{Diagram klas}

\tab Program składać się będzie z 9 klas. Zależności pomiędzy poszczególnymi klasami obrazuje Rysunek 1.

Na diagramie klas nie zostały uwzględnione:

\begin{itemize}
\item zależności pomiędzy klasami Parser, MainWindow, AreaDivider oraz klasami będącymi składowymi klasy Map, w celu poprawy czytelności,
\item metody wygenerowane przez WPF, odpowiadające za rysowanie na planszy oraz reakcję na zachowanie użytkownika.
\end{itemize}

Nie występują na nim także metody dostępowe ze względu na zastosowanie automatycznie generowanych właściwości klas występujące w wybranym przez nas środowisku.

\begin{figure}[H]
\centering
\includegraphics[width=15cm]c
\caption{Diagram klas}
\label{fig:obrazek c}
\end{figure}

\newpage

\section{Opis klas/metod}


\subsection{Klasa MainWindow}

\tab Jest to bazowa klasa tego programu, odpowiadająca przede wszystkim za interfejs graficzny. Składa się ona z wielu metod wygenerowanych przez WPF, odpowiadających za reakcję na działania użytkownika. Wśród najważniejszych logicznych implementacji, które muszą być zawarte w implementacjach tych metod, warto wspomnieć o:
\begin{itemize}
\item metodzie, która po kliknięciu w okolicy punktu kluczowego wypisze na panelach bocznych listy obiektów znajdujących się na obszarze wyznaczonym przez ten punkt kluczowy (pogrupowane i niepogrupowane według typu) oraz liczbę mieszkańców na tym obszarze,
\item metodzie, która przy wybranej opcji punktu kluczowego po kliknięciu lewym przyciskiem myszy dodaje punkt kluczowy, a prawym przyciskiem usuwa najbliższy punkt kluczowy,
\item analogicznej metodzie która dodaje i usuwa elementy konturu po wybraniu opcji konturu na pasku górnym.
\end{itemize}

Po wybraniu opcji usuwania/dodawania punktów na mapie następuje wywołanie funkcji \textit{DivideIntoAreas} ponownie dzielącej mapę na obszary, z klasy \textit{AreaDivider}.


\subsection{Klasa Parser}

\tab Ta klasa odpowiada za wczytanie danych z pliku tekstowego, które zostaną użyte w trakcie działania programu. Wszystkie metody w tej klasie są statyczne, przez co obiekt klasy Parser nie będzie powstawać w żadnym momencie trwania programu. Metody te w przypadku niepowodzenia korzystają z wyjątków, które przekazują do metody nadrzędnej -- metoda \textit{ParseFile} przekazuje te wyjątki do klasy \textit{MainWindow}, która odpowiada za przekazanie komunikatu o błędzie użytkownikowi.

\subsubsection{Metoda ParseFile}
\begin{itemize}
\item \begin{lstlisting}
Map ParseFile(string imputFilePath) 
\end{lstlisting}
\end{itemize}

Metoda \textit{ParseFile} jest główną metodą tej klasy. Otrzymuje ona ścieżkę do pliku w postaci napisu, po czym ma za zadanie otworzyć ten plik, przeanalizować każdą jego linię oraz zapisać dane w postaci zrozumiałej dla programu. Na podstawie składni pliku oraz linii oddzielających etapy wczytywania, oznaczonych \# na początku, odczytuje linię tekstu i przekazuje ją do odpowiedniej metody parsującej. Po zakończeniu kolejnego etapu metoda sprawdza, czy żaden z warunków działania programu nie został złamany -- na przykład, czy użytkownik nie zamieścił przecinających się linii konturu lub nie zapomniał o którymś z obowiązkowych typów obiektów. Odczytane w ten sposób dane zapisuje do list w obiekcie klasy \textit{Map}, po czym w przypadku powodzenia zwraca referencję do tak przygotowanego obiektu. 


\subsubsection{Metoda ParseContourPoint}

\begin{itemize}
\item \begin{lstlisting}
Point ParseContourPoint(string line)
\end{lstlisting}
\end{itemize}

\tab Jest to pierwsza ze szczegółowych metod tej klasy, odpowiadających za odczytanie konkretnych elementów podanych w pliku. Ta konkretna metoda odczytuje linię zawierającą współrzędne punktów konturowych, po czym w przypadku powodzenia zwraca przygotowany obiekt klasy \textit{Point}.

\subsubsection{Metoda ParseKeyPoint}

\begin{itemize}
\item \begin{lstlisting}
KeyPoint ParseKeyPoint(string line)
\end{lstlisting}
\end{itemize}

\tab Jest to kolejna metoda odczytująca linię. Odczytuje ona linię zawierającą współrzędne punktów kluczowych i ich nazwy, po czym w przypadku powodzenia zwraca przygotowany obiekt klasy \textit{KeyPoint}.

\subsubsection{Metoda ParseCustomObjectType}

\begin{itemize}
\item \begin{lstlisting}
CustomObjectType ParseCustomObjectType(string line)
\end{lstlisting}
\end{itemize}

\tab Ta metoda odpowiada za odczytanie deklaracji typu obiektu przygotowanej przez użytkownika. Do jej zadań należy sprawdzenie, czy użytkownik napisał dla każdego parametru nazwę i typ, oraz czy program potrafi rozpoznać ten typ.

\subsubsection{Metoda ParseCustomObjectInstance}

\begin{itemize}
\item \begin{lstlisting}
CustomObjectInstance ParseCustomObjectInstance(string line,
 List<CustomObjectType> customObjectTypes)
\end{lstlisting}
\end{itemize}

\tab Ta metoda odczytuje obiekty wypisane przez użytkownika, zgodnie z zadeklarowanymi przez niego typami na poprzednim etapie odczytu. Do jej zadań należy sprawdzenie, czy podane obiekty są zgodne z deklaracjami dokonanymi wcześniej. Tak jak każda z wymienionych powyżej metod poprawnie odczytany obiekt zwraca do metody głównej tej klasy -- \textit{ParseFile}.

\subsection{Klasa 3}
\tab 

\subsubsection{metoda}
\begin{itemize}
\item \begin{lstlisting}
public CurrencyMatrix (int n)
\end{lstlisting}
\end{itemize}

\tab standard listingu

\subsection{Klasa 4}

\tab coś robi


\subsection{Klasa 5}

\tab xxx

\subsection{Klasa 6}

\tab W tej klasie coś

\subsubsection{Metoda 1}



\subsubsection{Metoda 2}



\section{Działanie programu i zastosowanie algorytmu}

\tab Pełna sekwencja. Opis algorytmu może być problematyczny na tym etapie

\section{Testy jednostkowe}

\tab Projekty testów zakładają użycie narzędzia ???. Poniżej znajduje się lista testów planowanych dla kluczowych metod programu, dla każdej z nich przewidziane są różne przypadki otrzymanych danych. 

\subsection{Testy klas 1 i 2}

\tab W tych dwóch nie trzeba wiele testować

\subsection{Testy klasy 3}

\tab coś trzeba tu stestować

\subsection{Testy klasy 4}

\tab Tu testujemy coś


\subsection{Testy klasy 5}

\tab Ta klasa ma coś

\subsection{Testy klasy 6}

\tab Ta klasa odpowiada za coś



\end{document}